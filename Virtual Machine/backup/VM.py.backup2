#!/usr/bin/env python3

'''tECS-VM-to-HACK-Assembly Translator

Converts tECS-spec VM code to Hack Assembly code
tECS VM language, Hack Assembly, and the Hack architecture are all defined in The Elements of Computing Systems [2005].

The virtual machine \"implemented\" here is a stack machine, featuring:
- Basic arithmetic and logical ops (add/sub, negation, [in]equality testing, &c)
- Basic stack operations (push/pop)
- A stack with logical variable segmentation (local and argument sections)
- Defined constructs for structured programming (function labels and calls, conditionals AND labeled-gotos and conditional jumps native that map directly to assembly)
- Special purpose registers (e.g. for handling implicit object references: \'this\'),
- General purpose registers (R5 through R12),
Basically a lot of niceties left undefined on the bare-bones, two-register Hack architecture.

The converter is non-optimizing, but the introduction of some extra instructions could help.

The converter assumes correct VM code, generated by a compiler (NOT hand-written).
It generates error messages, and will catch if code uses operators undefined in tECS VM, but it isn't thorough about checking for bad semantics or things outside the very primitive \"grammar\" of tECS VM.'''


#TO-DOs:
# - for `return' code, output the code a single time and replace all VM-command instances of it with a
#    jump to that point. Refresh yourself on labeling conventions, so that you can give the single
#    instance of `return' a unique label.
#
# - for `function NAME n',
#     @SP
#     A=M
#     M=0
#     @SP
#     M=M+1
#   is outputted `n' times. Instead of outputting it for each time, replace it with a decrement and JMPs.
#
# - Optimize `call NAME n'. With some indirection, you could do away with tons of redundant code
#    generation, since the only difference between invocations of `call NAME n' are different `n's
#    issued, and different labels.
#
#            | call RAY 0     | call RAY 2     | call DAVE 2     |
#            |----------------+----------------+-----------------|
#            |    ...         |    ...         |     ...         |
#            | @5             | @7             | @7              |  ***** value = n + 5
#            | D=D-A          | D=D-A          | D=D-A           |
#            | @ARG           | @ARG           | @ARG            |
#            | M=D            | M=D            | M=D             |
#            | @SP            | @SP            | @SP             |
#            | D=M            | D=M            | D=M             |
#            | @LCL           | @LCL           | @LCL            |
#            | M=D            | M=D            | M=D             |
#            | @RAY           | @RAY           | @DAVE           |
#            | 0;JMP          | 0;JMP          | 0;JMP           |
#            | (RTN_ADR_RAY0) | (RTN_ADR_RAY0) | (RTN_ADR_DAVE0) |  *****
#
# - Clean up the `bootstrap code', so that use JMP and a decrement to repeat:
#                    @SP
#                    A=M
#                    M=0
#                    @SP
#                    M=M+1
#   , instead of repeating the instructions.
#
# |||| The key to all three  of the above would seem to be claiming part of static memory to use as a work
# ||||  space, so's to store things like the number of repetitions for running variable initialization/
# ||||  allocation at the heads of `function's AND storing (perhaps) the `n' variable for `call NAME n'
#
#
# - Tally static variables as they accumulate, so that you can keep the VM
#    converter from spitting out static variables beyond their allocated space
#    [16 through 255 or 240 spots].
#      + this'd require making sure that the (label) / @label function that
#        @name also serves doesn't generate labels that conflict.
#         ^^^^^^^^^^^^^^^^^ UPDATE: THEY DOESN'T CONFLICT
#
# - Make existing error more checking meaningful
# - Make the path-handling non-Windows specific
# - Make a command line interface for this thing
#+============================================================================+

import sys

class VM():
    arithlogicoperations = ['add', 'sub', 'neg', 'eq', 'gt', 'lt', 'and', 'or', 'not']
    memoryoperations     = ['push', 'pop']
    programflowcommands  = ['label', 'goto', 'if-goto']
    functioncallcommands = ['function', 'call', 'return']
    nopointnostaticDict  = {'argument':'ARG', 'local':'LCL', 'this':'THIS', 'that':'THAT'}
    pointerandtempDict   = {'pointer':  {'0':'THIS',  '1':'THAT'}, \
                            'temp':     {'0':'R5',    '1':'R6',   '2':'R7',   '3':'R8',
                                         '4':'R9',    '5':'R10',  '6':'R11',  '7':'R12'}}


global file_                    # This is the variable we use for all output. Instance of `Output`

class Output(object):
    '''Wrapper for a file object. We do ALL our output through an instance of this class.
    If we instantialize our object with the path to a file [i.e., instance = Output('this/is/a/file')],
    output goes to that file.

    If we don't (i.e. we pass it no value--instance = Output(None), output defaults to STDOUT, AND
    keeps a tally of the number of operations we output. This is purely for purposes of the
    interpreter.

    Dynamically-defined method:

    out(string)
        This is raison d'Ãªtre of the entire class. We use it for all of our...output. '''

    def __init__(self, filename=None):
        '''Defines instance.out(string) -- the method we'll be using for all our output'''
        if filename != None:    # file
            self.fileobject = open(filename, 'w')
            self.out = self.fileobject.write
        else:                   # STDOUT + bookkeeping
            self.out = self.interpreterOutput
            self.N_INSTRUCTIONS = 0

    def close(self):
        '''Closes our file object. This is unnecessary, if you're simplying using STDOUT \
i.e. if you're using our interpreter).'''
        self.fileobject.close()

    def interpreterOutput(self, line):
        '''Output function for the interpreter. Tracks the number of instructions output'd '''
        instructions = line.split()   # Just counting any line that
        n = len(instructions)         # isn't a (goto_label) --
        for i in instructions:        # remember that labels are
            if i[0] == '(':           # pseudo instructions
                n -= 1                # ..
        self.N_INSTRUCTIONS += n      # .
        sys.stdout.write(line)
######


def vmtoassembly(pathorfile, outputfile='whatever.asm', custom_out_dir=None, bootstrap=True):
    '''Accepts a path--either to a single VM file or to a directory--and converts file or files ending in .vm to a single assembly file.
Main function'''
    import os
    global file_

    filelist = fileorpathparser(pathorfile)

    if custom_out_dir: directory = custom_out_dir
    else: directory = os.path.dirname(filelist[0])
    asmfilepathname = os.path.join(directory, outputfile)

    try:
        file_ = Output(asmfilepathname)
    except:
        raise('TRANSLATION FAILURE. You seem not to have write permission.')

    n_to_translate = len(filelist)
    globallyuniqueNUM = 1

    if bootstrap:
        writeBootstrap()

    for file in filelist:
        try:
            read = open(file)
        except:
            raise RuntimeError('Could not open file. Maybe check permissions.')

        moduleprefix = os.path.basename(file)[:-3]
        linenum = 1
        for line in read:  # For some reason, I chose `line' as the name of the iterable, here. Oops.
            line = makelist(line) # `line' is now a list of operators and arguments.

            try:
                OP = line[0]
                if OP in VM.arithlogicoperations:
                    processArithmeticLogic(line, linenum, globallyuniqueNUM)

                elif OP in VM.memoryoperations and len(line) == 3:
                    if not processPushPop(line, moduleprefix):
                        raise

                elif OP in VM.programflowcommands:
                    processProgramFlow(line, moduleprefix)

                elif OP in VM.functioncallcommands:
                    processFunctionCmds(line, globallyuniqueNUM)

                elif OP == '': pass

                else:
                    raise
            except: # I honestly don't know what could go wrong, apart from reading the wrong syntax.
                    # I guess we're being extra careful, here.
                    raise RuntimeError("Line %s. Something went wrong. Conversion halted." % linenum)
            linenum += 1; globallyuniqueNUM += 1

        n_to_translate -= 1
        read.close()
        print(file+" translated. "+str(n_to_translate),"file(s) to go.")
    print("Output file:", asmfilepathname,"\n")
    file_.close()


def fileorpathparser(path):
    '''Returns a list containing either the single .vm file `path' points to, or the .vm files in the specified directory'''
    import os; import glob
    try:
        if path.endswith('.vm'):
            files = [path]
        else:
            files = []  # enter'd nonsense
            for infile in glob.glob(os.path.join(path, '*.vm')):
                files.append(infile)
            if files == []:
                raise
    except:
        raise RuntimeError("Badly formed file or path name, %s doesn't exist, or it doesn't  point to .vm files" % path)
    return files

def makelist(line):
    '''Turns a line (string) into a nice li'l list of separate tECS-VM tokens (assuming the input is tECS-VM, to begin with).
    str->[]'''
    line = line.split('//')[0]
    line = line.replace('\t', ' ')       # Normalize whitespace separators
    line = line.strip().split(' ')
    line = [x for x in line if x != '']  # pour on the list comprehension
    if line == []: line = ['']
    return line

def writeBootstrap():
    '''
    Writes the bootstrap code that:
    - initializes SP, LCL, and ARG to the right values
    - calls Sys.init (part of Jack Standard Library):
        ++Pushes Sys.init's return address onto the stack, i.e.,
            "@RTN_ADR_Sys.init"
        ++Pushes 0s onto the stack where a normal function call would push
            LCL, ARG, THIS, and THAT
        ++Writes the goto Sys.init statement
        ++Writes the return address token, i.e. \"(RTN_ADR_Sys.init)\"'''

    file_.out("@256\nD=A\n@SP\nM=D\n@LCL\nM=D\n")         #SP=256; LCL = SP

    # \\\ /// call Sys.init--{Memory,Math,Output,Keyboard,Screen,String,Main}.init
    #            + Sys.halt--in that order)
    file_.out("@RTN_ADR_Sys.init\nD=A\n@SP\nA=M\nM=D\n@SP\nM=M+1\n") # push Sys.init's return address
    for i in range(4):  # pushes zeros on the stack (just in case system start-up doesn't default to
        file_.out("@SP\nA=M\nM=0\n@SP\nM=M+1\n")  #                                             zeros.
    file_.out("@256\nD=A\n@ARG\nM=D\n")           #  ARG = SP-n-5
    file_.out("@Sys.init\n0;JMP\n")               # `goto Sys.init'
    file_.out("(RTN_ADR_Sys.init)\n")             # (return-address)


arithlogicToAssembly = {
    'add':"@SP\nAM=M-1\nD=M\n@SP\nAM=M-1\nM=M+D\n@SP\nM=M+1\n",
    'sub':"@SP\nAM=M-1\nD=M\n@SP\nAM=M-1\nM=M-D\n@SP\nM=M+1\n",
    'neg':"@SP\nAM=M-1\nM=!M\nM=M+1\n@SP\nM=M+1\n",

    'eq':
        "@SP\nAM=M-1\nD=M\n@SP\nAM=M-1\nD=M-D\n@EQTRUE{}\nD;"\
        "JEQ\nD=0\n@ENDEQ{}\n0;JMP\n(EQTRUE{})\nD=-1\n"\
        "(ENDEQ{})\n@SP\nA=M\nM=D\n@SP\nM=M+1\n",

    'gt':
        "@SP\nAM=M-1\nD=M\n@SP\nAM=M-1\nD=M-D\n@GTTRUE{}\nD;"\
        "JGT\nD=0\n@ENDGT{}\n0;JMP\n(GTTRUE{})\nD=-1\n"\
        "(ENDGT{})\n@SP\nA=M\nM=D\n@SP\nM=M+1\n",

    'lt':
        "@SP\nAM=M-1\nD=M\n@SP\nAM=M-1\nD=M-D\n@LTTRUE{}\nD;"\
        "JLT\nD=0\n@ENDLT{}\n0;JMP\n(LTTRUE{})\nD=-1\n"\
        "(ENDLT{})\n@SP\nA=M\nM=D\n@SP\nM=M+1\n",

    'and':"@SP\nAM=M-1\nD=M\n@SP\nAM=M-1\nM=M&D\n@SP\nM=M+1\n",
    'or':"@SP\nAM=M-1\nD=M\n@SP\nAM=M-1\nM=M|D\n@SP\nM=M+1\n",
    'not':"@SP\nAM=M-1\nM=!M\n@SP\nM=M+1\n",
}
def processArithmeticLogic(line, linenum, gID):
    '''Receives `line' (list of VM tokens); line[0] is ostensibly a VM operator. Writes the relevant assembly to the output file'''
    ### This function is /definitely/ a candidate for replacement with a dictionary that returns the relevant
    ###  string for each operator. E.g., {'add':'@SP\nAM=M1...', ..., 'eq':'SP...@EQTRUE%s\n', etc}
    if len(line) != 1:
        print("Line "+str(linenum)+". Warning: Arithmetic and Logical ",end="", file=sys.stderr)
        print("operations on the stack don't take arguments. Make",end="", file=sys.stderr)
        print("sure you know what your code does.\n", file=sys.stderr)
    file_.out(arithlogicToAssembly[line[0]].format(gID, gID, gID, gID))

def processPushPop(line, module):
    '''Receives a line (as a list) with a push/pop operation in it; writes the relevant assembly to the output file'''
    operator, location, offset = line[0], line[1], line[2]
    if operator == 'push':
        if location in ['argument', 'local', 'this', 'that']:
            area = VM.nopointnostaticDict[location]
            if offset == '0':
                file_.out("@"+area+"\nA=M\nD=M\n@SP\nA=M\nM=D\n@SP\nM=M+1\n")
            else:
                file_.out("@"+offset+"\nD=A\n@"+area+"\nA=M+D\nD=M\n@SP\n")
                file_.out("A=M\nM=D\n@SP\nM=M+1\n")
        elif location == 'constant':
            file_.out("@"+offset+"\nD=A\n@SP\nA=M\nM=D\n@SP\nM=M+1\n")
        else:
            if location == 'static':
                area = module + "." + offset
            elif location in ['pointer', 'temp']:
                try:
                    area = VM.pointerandtempDict[location][offset]
                except:
                    return False
            else:
                return False
            file_.out("@"+area+"\nD=M\n@SP\nA=M\nM=D\n@SP\nM=M+1\n")

    elif operator == 'pop':
        if location in ['argument', 'local', 'this', 'that']:
        # no memory-bounding checks
            area = VM.nopointnostaticDict[location]
            if offset == '0':
                file_.out("@SP\nAM=M-1\nD=M\n@"+area+"\nA=M\nM=D\n")
            else:
                file_.out("@"+offset+"\nD=A\n@"+area+"\nD=M+D\n@R13\nM=D\n")
                file_.out("@SP\nAM=M-1\nD=M\n@R13\nA=M\nM=D\n")
        else:
            if location == 'static':
                area = module + "." + offset
            elif location in ['pointer', 'temp']:
                try: #<<< out of memory range will trigger exception
                    area = VM.pointerandtempDict[location][offset]
                except:
                    return False
            else:
                return False
            file_.out("@SP\nAM=M-1\nD=M\n@"+area+"\nM=D\n")
    return True

def processProgramFlow(line, module):
    '''Processes a VM `line' prefixed by `goto', `label', and `if-goto' '''
    if len(line) != 2:
        print(line[0]+" commands accept two arguments, or your label",end=" ", file=sys.stderr)
        print("name contains a space.", file=sys.stderr)
    else:
        # My implementation of the command `label /label/` -> functionName$label
        #  assumes the compiler has generated unique names for labels.
        command, label = line[0], line[1]
        if command == 'label':
            file_.out("("+module+"$"+label+")\n")
        elif command == 'goto':
            file_.out("@"+module+"$"+label+"\n0;JMP\n")
        else: #'if-goto'
            file_.out("@SP\nAM=M-1\nD=M\n@"+module+"$"+label+"\nD;JNE\n")

def processFunctionCmds(line, gID):
    '''Accepts `line' (list of VM tokens), parses it, writes assembly for one of
    the following:
    (1) 'call' -- defines return address, saves function state on the
        stack, writes return token (i.e. a goto destination)
    (2) 'function' definition -- goto token and variable initialization
    (3) 'return' -- pops return value onto the stack, restores state of
        calling function.
    ####### See pg. 163 of tElements of Computing Systems for details#########
    '''
    if len(line) == 3:
        operation, function, n_lcl_vars = line[0], line[1], line[2]
    else:
        operation = line[0]
        if len(line) != 1:
            raise SyntaxError("Seems your invocation of `%s' wasn't syntactically correct" % (operation), file=sys.stderr)

    if operation == 'call':
    # The assembly here:
    # (1) Saves the state of the calling function, by pushing @return_address, LCL, ARG, THIS, and
    #      THAT onto the stack
    # (2) Changes the value of ARG so that it points below all the state-save values pushed above
    #      (ARG = SP-n-5), n=number of funct arguments
    # (3) Points LCL to the top of the stack, where the called function will put its local variables
    # (4) Writes a jump to the function
    # (5) Defines a return address by pushing an assembly label [i.e. "(returnadr)"] at end of assembly output

    # Afterwards, stack looks as follows:
    #    +-------------------------------+
    #    |      argument 0               |  <= ARG; function(arg1, arg2, argN-1);
    #    |      argument 1               |      Calling function has pushed arguments onto the stack.
    #    |        ...                    |      They reside here, right before saved context info (\/)
    #    |      argument n-1             |      These `push's happened just before `call f n' was issued
    #    +-------------------------------+
    #    |     return_address            |  <= NONE of the registers point here. This is simply the place 
    #    |       saved LCL               |      the prior context gets saved. VM code (& by extension Jack
    #    |       saved ARG               |      code compiled to VM) will NOT interact with this, EXCEPT
    #    |       saved THIS              |      for `return', which puts these values into their proper 
    #    |       saved THAT              |      registers and JMPs to `return_address'
    #    +-------------------------------+
    #    |       local 0                 |  <= LCL; these are the local variables of the function we've
    #    |       local 1                 |      now entered or about to enter (depending on perspective).
    #    |        ...                    |      The function in question will begin by pushing the 
    #    |       local k-1               |      initial values into these variables.
    #    +-------------------------------+
    #    |                               |  <= SP; initial place the SP points, after entering a function
    #    +-------------------------------+      (and after variables are initialized)

        #### \/ precall push \/ ##########################################
        returnadr = "RTN_ADR_"+function+str(gID)                         # << Pushes return address
        file_.out("@"+returnadr+"\nD=A\n@SP\nA=M\nM=D\n@SP\nM=M+1\n")   #    onto the stack
        for label in ['LCL','ARG','THIS','THAT']:
            # Pushes values contained in LCL (RAM[1]), ARG (RAM[2]), THIS (RAM[3], THAT (RAM[4]) onto
            #  the stack, where a `return` can later unpack them.
            file_.out("@"+label+"\nD=M\n@SP\nA=M\nM=D\n@SP\nM=M+1\n")
        #### /\ precall push /\ #########################################

        # ARG=SP-n-5, i.e. points ARG to the 0th argument. Function arguments are pushed before a `call`
        #  is initiated \/
        nplus5 = str(int(n_lcl_vars) + 5)
        file_.out("@SP\nD=M\n@"+nplus5+"\nD=D-A\n@ARG\nM=D\n")

        file_.out("@SP\nD=M\n@LCL\nM=D\n")         #LCL = SP;
        file_.out("@"+function+"\n0;JMP\n")        # Goto `function'
        file_.out("("+returnadr+")\n")	            # Writes return address

    elif operation == 'function':
    # (1) writes a label for the function destination, i.e. "(function_name)"
    # (2) initializes variables by pushing 'n' varibles onto the stack, where
    #      n = number of local variables'''
        file_.out("("+function+")\n")                     #(function_name)
        for i in range(int(n_lcl_vars)):
            file_.out("@SP\nA=M\nM=0\n@SP\nM=M+1\n")      #pushes n zeros

    else:
    # == 'return'
    # (1) puts the return address into R14 (temp register)
    # (2) pops the return value of the function to the memory location pointed
    #     to by ARG, i.e. SP-n-5, i.e. the value that SP had before pushing
    #     its n function arguments.
    # (3) puts the stack pointer right above the returned value (i.e. ARG+1)
    # (4) puts the state-save values that the calling function put on the stack
    #     back into THAT, THIS, ARG, and LCL
    # (5) JMPs to the return address (defined by the writing of the function
    #     call)'''
        file_.out("@LCL\nD=M\n@R13\nM=D\n")               #FRAME = LCL
        file_.out("@R13\nD=M\n@5\nA=D-A\nD=M\n@R14\nM=D\n")#RET = *(FRAME-5)
        file_.out("@SP\nAM=M-1\nD=M\n@ARG\nA=M\nM=D\n")  #*ARG = pop()
        file_.out("@ARG\nD=M+1\n@SP\nM=D\n")             #SP = ARG+1
        for l in ['THAT', 'THIS', 'ARG', 'LCL']:           #/THAT, THIS, ARG,
            file_.out("@R13\nAM=M-1\nD=M\n@"+l+"\nM=D\n") #\LCL=*(FRAME-[n+1])
        file_.out("@R14\nA=M\n0;JMP\n")                   #@return-address;JMP






### Interpreter section (unessential code):

def VMinterpreter():
    '''An `interpreter' for tECS VM commands. Doesn't execute VM commands, but outputs their
Hack translation. Gives some insight into the translation, itself. Some syntactically-
invalid commands will print, because I don't want to pollute the logic of the
translator.'''
    while True:
        try:
            thing = input("Type a VM command, 'bootstrap', OR type 'h' for help or 'q' to quit: ")
            print()
            printVMcmd(thing)
        except EOFError:
            print('BYE')
            break
        except:
            print("\nSomething went wrong. Conversion halted.")
            break

def printVMcmd(command):
    '''======================================================================================
Commands:
   arithmetic/logical ops:      add, sub, neg, eq, gt, lt, and, or, not

   stack operations:            push LOCATION n, pop LOCATION m
                          e.g.,`push local 0', `pop local 3', `push argument 0',
                               `pop argument 0', `push temp 0', `pop temp 1'

   program flow commands:       label VARIABLE, goto VARIABLE, if-goto VARIABLE
   structured programming:      function NAME n, call NAME k, return
======================================================================================
Labeled Memory Locations:       argument, local, this, pointer 0 (`this'), pointer 1 (`that'),
                                temp 0/1/2/3/4/5/6/7
======================================================================================'''


    global file_
    file_ = Output(None)

    globallyuniqueNUM = linenum = 0
    moduleprefix = "interpreter"
    command = command.split()

    if command == []:
        OP = ''
    else:
        OP = command[0]

    if OP in VM.arithlogicoperations:
        processArithmeticLogic(command, linenum, globallyuniqueNUM)
    elif OP in VM.memoryoperations and len(command) == 3:
        processPushPop(command, moduleprefix)
    elif OP in VM.programflowcommands:
        processProgramFlow(command, moduleprefix)
    elif OP in VM.functioncallcommands:
        if len(command) == 1 and command[0] != 'return':
            command.append('function')
            command.append('0')
        processFunctionCmds(command, globallyuniqueNUM)
    elif OP == 'bootstrap':
        writeBootstrap()
    elif OP == 'h':
        print(VMinterpreter.__doc__ + '\n' + printVMcmd.__doc__)
    elif OP == 'q':
        raise EOFError          # sloppy exit
    else:
        print('Malformed command, I guess. Try again!')

    print('\n'+str(file_.N_INSTRUCTIONS)+' instructions')


if __name__ == '__main__':
    VMinterpreter()
